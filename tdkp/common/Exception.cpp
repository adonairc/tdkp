// ------------------------------------------------------------
//
// This file is part of tdkp, a simulation tool for nanostrutctures
// of optoelectronics developed at ETH Zurich
//
// (C) 2005-2009 Ratko G. Veprek, ETH Zurich, veprek@iis.ee.ethz.ch
//
// 1) As of 18.6.2009 this code is property of ETH Zurich and must not be
// transferred, modified or used by third parties without appropriate
// licenses issued by authorized agents of ETH Zurich.
//
// 2) Violation of this will result in judicial action according to civil
// and penal law.
//
// 3) Any claim of authorship other than by the author himself is
// strictly forbidden.
//
// 4) The source code must retain the copyright notice, this list
// of conditions and the following disclaimer.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
// BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
// BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
// OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
// IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ------------------------------------------------------------


#include <stdarg.h>
#include <stdio.h>
#include <cstring>

#include "tdkp/common/all.h"
#include "tdkp/common/Exception.h"
#include "tdkp/common/Logger.h"
// bin/Version.h is generated in ./bin directory
#include "bin/Version.h"


namespace tdkp {

// -----------------------------------------------------
// class implementation
// -----------------------------------------------------
Exception::~Exception() {

}

Exception::Exception()
: reason("") 
{
		
}

/** create exception with detailed information 
 * 
 * general exceptions should be generated by precompiler templates for emitting precise
 *
 * @param explaining reason for exception
 * @param line line where exception was created (precomp directives)
 * @param pfile source file name where exception was raised
 * @param ptime compile time of source file object
 * @param pdate compile date of source file object
 * */
Exception::Exception(const char* preason, int line, const char* pfile, const char* pdate, const char* ptime) {
	this->reason = preason;	
	this->append_info(line, pfile, pdate, ptime);
	this->reason.append("\n");	
	this->write_to_log();	
}

/** create exception with detailed information */
Exception::Exception(const std::string& reason_, int line, const char* pfile, const char* pdate, const char* ptime) {
	this->reason = reason_;
	this->append_info(line, pfile, pdate, ptime);
	this->reason.append("\n");		
	this->write_to_log();	
}

/** create exception with detailed information and the function name where it occured */
Exception::Exception(const string& reason_, int line, const char* pfile, const char* pdate, const char* ptime, const char* pfunc) {
	this->reason = reason_;
	this->append_info(line, pfile, pdate, ptime,pfunc);
	this->reason.append("\n");		
	this->write_to_log();
}
/** create exception with detailed information and the function name where it occured */
Exception::Exception(const char* preason,  int line, const char* pfile, const char* pdate, const char* ptime, const char* pfunc) {
	this->reason = preason;
	this->append_info(line, pfile, pdate, ptime,pfunc);
	this->reason.append("\n");		
	this->write_to_log();	
}


/** create exception with detailed information using sprintf type argument list 
 * @param buflen  buffer length which will be used for sprintf (MUST BE BIGGER THAN OUTPUT MSG)
 * @param preason format string for sprintf
 * @param ...     arguments for sprintf
 * */
Exception::Exception(unsigned int buflen, const char* preason, ...) {
	// sprintf preason
   	va_list args;
   	va_start(args,preason);
   	char* buf = new char[buflen];
   	vsprintf(buf, preason, args);
	this->reason = buf;
	this->reason.append("\n");	
   	delete[] buf;	
	this->write_to_log();   	
}

/** append exception place, file and version to reason */
void Exception::append_info(int line, const char* pfile, const char* pdate, const char* ptime, const char* pfunc) {

	ostringstream sout;
	if(pfunc != 0) {
		sout << "Exception raised in function " << pfunc << " " 
			 << "on line " << line << " in file " << pfile << "\n"
			 << "Version information: tdkp revision " << TDKP_REVISION << " "
			 << "compiled at " << pdate << " " << ptime << " on " << MACHINE
			 << "\n";
	} else {
		sout << "Exception raised on line " << line << " in file " << pfile << "\n"
			 << "Version information: tdkp revision " << TDKP_REVISION << " " 
			 << "compiled at " << pdate << " " << ptime << " on " << MACHINE
			 << "\n"; 
	}			 
	this->reason.append("\n");
	this->reason.append(sout.str()); 	
}
/** return exception reason */ 
const std::string&  Exception::get_reason() const {
	return this->reason;	
}
/** file exceptions - show filename that caused the exception */ 
FileException::FileException(const char* preason, const char* filename, int line, const char* pfile, const char* pdate, const char* ptime) {
	this->reason = preason;
	this->reason.append(":");
	this->reason.append(filename);
	this->append_info(line, pfile, pdate, ptime);
	this->reason.append("\n");		
	this->write_to_log();	
}
/** parser exception - give hint and show line which caused trouble 
 * @param preason reason of failure
 * @param filename filename of file to parse
 * @param line_number line number that caused parser error
 * @param line that caused parser error
 */
ParserException::ParserException(const char* preason, const char* filename, int line_number, std::string& line) {
	char* buf = new char[strlen(filename) + 100 + strlen(preason)];
	sprintf(buf,"error in input file %s on line %d: %s\n ... ", filename, line_number, preason);
	this->reason.append(buf);
	this->reason.append(line);
	this->reason.append("\n");
	delete buf;	
	this->write_to_log();
}

// -----------------------------------------------------
// outstreams
// -----------------------------------------------------
std::ostream& operator<<(std::ostream &out, const Exception& pe) {
	out << pe.get_reason();
	return out;	
}

void Exception::write_to_log() const {
	Logger::get_instance()->emit(LOG_ERROR, this->reason);	
}

} // end of namespace
